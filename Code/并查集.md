# 并查集
并查集通俗讲解：https://blog.csdn.net/qq_41593380/article/details/81146850
##### 简单总结
并查集由三部分组成：搜索，路径压缩，合并  
存储：一个数组，存放自己的上级结点，猜想这是在节点的编号是连续整数的情况下  
搜索：一级一级查找，返回自己所属连通域的根节点  
路径压缩：将所有属于该连通域的下级结点的上级节点设成其根节点  
搜索和路径压缩一同进行  
合并：将两个连通域的根节点合并为一个结点  

##### 解题时要点
首先需要写下面模板，基础的union、find、isConnected不用变  
1. 依据场景判断是否需要添加路径压缩的函数  
2. 构造函数需要依据题意来写，一般需要变  
3. 这个类只是辅助类，具体使用操作需另写主函数

## 模板

    class UnionFind {
        int[] parents;

        public UnionFind(int totalNodes) {  //构造函数
            parents = new int[totalNodes];
            for (int i = 0; i < totalNodes; i++) {
                parents[i] = i;
            }
        }
        // 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.
        void union(int node1, int node2) {
            int root1 = find(node1);
            int root2 = find(node2);
            if (root1 != root2) {
                parents[root2] = root1;
            }
        }

        int find(int node) {
            while (parents[node] != node) {
                // 当前节点的父节点 指向父节点的父节点.
                // 保证一个连通区域最终的parents只有一个.
                parents[node] = parents[parents[node]];
                node = parents[node];
            }

            return node;
        }

        boolean isConnected(int node1, int node2) {
            return find(node1) == find(node2);
        }
    }
